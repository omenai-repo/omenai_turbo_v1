1. Orders that are declined should not be accounted for as processing when trying to repurchase it
2. Update order request mail sent to gallery to remove the information that indicates they will add the quote data
3. Update all emails
4. Set up 24 hr limit for purchase

https://claude.ai/public/artifacts/afa4aa09-cce7-408f-9445-4b9268753ddf

Next-auth: https://claude.ai/public/artifacts/6485fd83-ba53-4e92-bff5-cd401b514f5c
Clerk: https://claude.ai/public/artifacts/39a24cbd-78cf-45a0-a5ad-b9a27596b21d

Go-to market stratgies: https://claude.ai/public/artifacts/cdbc9619-02ee-4843-8636-a2fa45880a48



import { ArtistCategory } from "@omenai/shared-types";

// Category price ranges: [base, max]
const CATEGORY_PRICE_RANGES: Record<ArtistCategory, [number, number]> = {
  Emerging: [500, 2500],
  "Early Mid-Career": [1500, 5500],
  "Mid-Career": [2500, 7500],
  "Late Mid-Career": [3000, 9000],
  Established: [7000, 15000],
  Elite: [12000, 50000],
};

// Medium Point Allocation (Now Max 30)
const MEDIUM_POINTS: Record<string, number> = {
  Photography: 5,
  "Works on paper": 7,
  "Acrylic on canvas/linen/panel": 11,
  "Oil on canvas/panel": 13,
  "Mixed media on paper/canvas": 17,
  "Sculpture (Resin/plaster/clay)": 20,
  "Sculpture (Bronze/stone/metal)": 30,
};

// Size Points Calculation (Now Max 70)
const calculateSizePoints = (width: number, height: number): number => {
  const area = width * height; // cm²

  // Clamp area to 40,000 (max range you want to support)
  const clampedArea = Math.min(area, 40000);

  // Distribute area into 10 buckets (each bucket = 4000 cm²)
  const bucketSize = 4000;
  const pointsPerBucket = 7;

  // Calculate which bucket it falls into (0-based index)
  const bucketIndex = Math.floor(clampedArea / bucketSize);

  // Final score: (bucket index + 1) * points per bucket
  return (bucketIndex + 1) * pointsPerBucket;
};

// Final price calculation using normalized logarithmic scaling
export const calculatePrice = (
  category: ArtistCategory,
  medium: string,
  width: number,
  height: number,
  k = 0.05
): number => {
  const [base, max] = CATEGORY_PRICE_RANGES[category];
  const mediumPoints = MEDIUM_POINTS[medium] || 0;
  const sizePoints = calculateSizePoints(width, height);
  const totalPoints = Math.min(mediumPoints + sizePoints, 100); // Cap at 100

  const normalizedLog = Math.log(k * totalPoints + 1) / Math.log(k * 100 + 1);

  const price = base + (max - base) * normalizedLog;

  return Math.round(price);
};
